// NOTE: this element is only intended to be used as a child of other elements
// it must not have `vertical` be reassigned.
class ZF_Scrollbar : ZF_Slider {
	static ZF_Scrollbar create(
		Vector2 pos, Vector2 size,
		ZF_SliderAnimator animator, bool vertical = true
	) {
		let ret = new("ZF_Scrollbar");

		ret.setBox(pos, size);
		ret.config(0.0, 0.0, 0.0, 0.0, 0.0, animator, vertical, true, NULL, "");

		return ret;
	}

	protected double barSize;

	protected double contentHeight;
	protected double shownHeight;

	void setContent(double contentHeight, double shownHeight) {
		self.contentHeight = contentHeight;
		self.shownHeight = shownHeight;
		recalculateValues();
	}

	void recalculateValues() {
		if (contentHeight == 0.0) return;
		setHigh(contentHeight - shownHeight);
		setHandleSize((shownHeight / contentHeight) * barSize);
	}
	
	override void onBoxChanged(ZF_AABB old) {
		Super.onBoxChanged(old);
		if (vertical) {
			barSize = box.size.y;
		} else {
			barSize = box.size.x;
		}
		recalculateValues();
	}
}

class ZF_OldScrollbar : ZF_Element {
	// these are intentionally not protected
	// since the only intended purpose of this element
	// is to be used in another element, which should deal with
	// encapsulation itself
	ZF_BoxTextures background;
	ZF_BoxDrawer bgDrawer;
	ZF_BoxTextures textures[3];
	ZF_BoxDrawer barDrawers[3];

	enum BarState {
		BarState_Normal,
		BarState_Hover,
		BarState_Click
	}

	double position;
	double size;

	protected BarState curBarState;

	protected double originalPos;
	protected Vector2 originalMousePos;
	protected bool clicking;

	void config(
		ZF_BoxTextures normal, ZF_BoxTextures hover = NULL,
		ZF_BoxTextures click = NULL, ZF_BoxTextures background = NULL
	) {
		self.background = background;
		self.textures[BarState_Normal] = normal;
		self.textures[BarState_Hover] = (hover != NULL) ? hover : normal;
		self.textures[BarState_Click] = (click != NULL) ? click : normal;
		self.alpha = 1.0;
	}

	static ZF_OldScrollbar create(
		Vector2 pos, Vector2 size,
		ZF_BoxTextures normal, ZF_BoxTextures hover = NULL,
		ZF_BoxTextures click = NULL, ZF_BoxTextures background = NULL
	) {
		let ret = new('ZF_OldScrollbar');

		ret.config(normal, hover, click, background);
		ret.setBox(pos, size);

		return ret;
	}

	void barBox(ZF_AABB ret) {
		ret.pos = (0, box.size.y * position);
		ret.size = (box.size.x, box.size.y * size);
	}

	override bool handleMousePosition(bool mouseBlock, Vector2 mousePos) {
		if (curBarState == BarState_Click) {
			if (size < 1.0) {
				let delta = mousePos - relToScreen((0, 0)) - originalMousePos;
				delta /= getScale();
				position = originalPos + delta.y / box.size.y;
				clampBarPos();
			}
		}
		else {
			ZF_AABB box; barBox(box);
			ZF_AABB screenBox; aabbToScreen(screenBox, box);
			if (!mouseBlock && isEnabled() && !getHoverBlock() && screenBox.pointCollides(mousePos)) {
				curBarState = BarState_Hover;
			}
			else {
				curBarState = BarState_Normal;
			}
		}

		return false;
	}

	override void drawer() {
		ZF_AABB beforeClip, clipRect;
		screenClip(beforeClip, clipRect);
		Screen.setClipRect(int(clipRect.pos.x), int(clipRect.pos.y), int(clipRect.size.x), int(clipRect.size.y));

		if (background) {
			bgDrawer.draw(self, (0, 0), box.size, background, true);
		}

		if (size < 1.0) {
			ZF_AABB box; barBox(box);
			barDrawers[curBarState].draw(self, box.pos, box.size, textures[curBarState], true);
		}

		Screen.setClipRect(int(beforeClip.pos.x), int(beforeClip.pos.y), int(beforeClip.size.x), int(beforeClip.size.y));
	}

	void clampBarPos() {
		position = clamp(position, 0.0, 1.0 - size);
	}

	override bool onUIEvent(ZF_UiEvent ev) {
		let mousePos = getGlobalStore().mousePos;
		if (ev.type == UIEvent.Type_LButtonDown) {
			ZF_AABB box; barBox(box);
			ZF_AABB screenBox; aabbToScreen(screenBox, box);
			if (!mouseBlock && isEnabled() && screenBox.pointCollides(mousePos)) {
				curBarState = BarState_Click;
				originalPos = position;
				originalMousePos = mousePos - relToScreen((0, 0));
				setHoverBlock(self);
			}
		}
		else if (ev.type == UIEvent.Type_LButtonUp) {
			ZF_AABB box; barBox(box);
			ZF_AABB screenBox; aabbToScreen(screenBox, box);
			if (!mouseBlock && screenBox.pointCollides(mousePos) && curBarState == BarState_Click) {
				curBarState = BarState_Hover;
			}
			else {
				curBarState = BarState_Normal;
			}
			setHoverBlock(NULL);
		}
		return false;
	}
}
