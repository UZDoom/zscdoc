class ZF_ScrollContainer : ZF_ElementContainer {
	protected ZF_Element scrollArea;
	ZF_Element getScrollArea() { return scrollArea; }
	protected ZF_Scrollbar bar;

	protected double scrollWidth;
	protected double scrollAreaHeight;
	protected double scrollNotchJump;
	protected double contentBarGap;

	void config(
		double scrollWidth, double scrollAreaHeight, double scrollNotchJump, double contentBarGap = 0.0
	) {
		self.scrollAreaHeight = max(scrollAreaHeight, box.size.y);
		self.scrollNotchJump = scrollNotchJump;
		self.contentBarGap = contentBarGap;
		self.scrollWidth = scrollWidth;

		scrollArea.setBox((0, 0), (box.size.x - scrollWidth - contentBarGap, scrollAreaHeight));
		bar.setBox((box.size.x - scrollWidth, 0.0), (scrollWidth, box.size.y));

		self.alpha = 1.0;
	}

	static ZF_ScrollContainer create(
		Vector2 pos, Vector2 size,
		double scrollWidth, double scrollAreaHeight, double scrollNotchJump,
		ZF_SliderAnimator scrollbarAnimator,
		ZF_Element scrollArea = NULL, double contentBarGap = 0.0
	) {
		let ret = new('ZF_ScrollContainer');

		ret.setBox(pos, size);

		if (scrollArea == NULL) {
			ret.scrollArea = ZF_Frame.create((0, 0), (0, 0));
		}
		else {
			ret.scrollArea = scrollArea;
		}
		ret.bar = ZF_Scrollbar.create((0, 0), (0, 0), scrollbarAnimator, true);

		ret.config(scrollWidth, scrollAreaHeight, scrollNotchJump, contentBarGap);
		ret.elements.push(ret.bar);
		ret.bar.master = ret;
		ret.elements.push(ret.scrollArea);
		ret.scrollArea.master = ret;
		
		ret.bar.setContent(ret.scrollAreaHeight, ret.box.size.y);
		ret.bar.setValue(0.0);

		return ret;
	}

	override bool onNavEvent(ZF_NavEventType type, bool fromController) {
		if (isFocused() && isEnabled()) {
			switch (type) {
			case ZF_NavEventType_Down: {
				let oldPos = bar.getValue();
				let newPos = oldPos;
				newPos += scrollNotchJump;
				bar.setValue(newPos);
				return bar.getValue() != oldPos;
			}
			case ZF_NavEventType_Up: {
				let oldPos = bar.getValue();
				let newPos = oldPos;
				newPos -= scrollNotchJump;
				bar.setValue(newPos);
				return bar.getValue() != oldPos;
			}
			}
		}
		return Super.onNavEvent(type, fromController);
	}

	override bool onUIEvent(ZF_UiEvent ev) {
		if (Super.onUIEvent(ev)) return true;
		let mousePos = getGlobalStore().mousePos;
		if (ev.type == UiEvent.Type_WheelDown || ev.type == UiEvent.Type_WheelUp) {
			ZF_AABB screenBox; boxToScreen(screenBox);
			if (isEnabled() && screenBox.pointCollides(mousePos)) {
				let dir = ev.type == UiEvent.Type_WheelDown ? 1.0 : -1.0;
				let oldPos = bar.getValue();
				let newPos = oldPos;
				newPos += dir * scrollNotchJump;
				bar.setValue(newPos);
				return bar.getValue() != oldPos;
			}
		}
		return false;
	}

	override void topDrawer() {
		scrollArea.setBox((0, 0), (box.size.x - scrollWidth - contentBarGap, scrollAreaHeight));
		bar.setBox((box.size.x - scrollWidth, 0.0), (scrollWidth, box.size.y));
		bar.setContent(scrollAreaHeight, box.size.y);
		ZF_AABB oldBox; scrollArea.getBox(oldBox);
		oldBox.pos.y = -bar.getValue();
		Console.printf("%f %f %f", bar.getLow(), bar.getHigh(), bar.getValue());
		scrollArea.setBox(oldBox.pos, oldBox.size);
		Super.topDrawer();
	}
}
